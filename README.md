# 24BitProcessorSimulator
An Integrated Timing and Functional Simulator of a MIPS-style 24-bit processor made as a final project for a Computer Architecture course.
# 24-Bit Pipelined MIPS-Style Processor Simulator

[![Unlicense](https://img.shields.io/badge/license-Unlicense-blue.svg)](http://unlicense.org/)

An Integrated Timing and Functional Simulator of a MIPS-style 24-bit pipelined processor, developed as a final project for a Computer Architecture course. This simulator models a 5-stage pipeline (IF, ID, EX, MEM, WB) and includes features like data forwarding, hazard detection with stalling, and branch/jump handling.

The development of this simulator was initially accelerated with the aid of Google's Gemini 2.5 Pro large language model. The project successfully executes a test program, achieving a Cycles Per Instruction (CPI) of approximately 1.19 on the provided test.

## Key Features

*   **24-bit Architecture:** Custom MIPS-style design with 24-bit data paths and instructions.
*   **5-Stage Pipeline:** Implements Instruction Fetch (IF), Instruction Decode (ID), Execute (EX), Memory Access (MEM), and Write-Back (WB) stages.
*   **Instruction Set:** Supports a subset of MIPS instructions:
    *   **R-type:** `add`, `sub`, `multlow`, `and`, `or`, `xor`, `slt`, `sll`, `srl`, `nop`
    *   **I-type:** `addi`, `lui`, `ori`, `sw`, `lw`, `bne`
    *   **J-type:** `j`
*   **Hazard Detection:** Implements load-use hazard detection, stalling the pipeline and inserting NOPs when necessary.
*   **Data Forwarding:** Includes forwarding logic to mitigate data hazards from EX/MEM and MEM/WB stages to the EX stage, and from EX, MEM, WB stages to the ID stage for branch comparisons.
*   **Branch & Jump Handling:** Supports conditional branches (`bne`) and unconditional jumps (`j`), including flushing the IF/ID pipeline register on taken branches/jumps.
*   **3-Byte Word Alignment:** Addresses and instructions are aligned to 3-byte boundaries, influencing branch/jump target calculations (e.g., using `MultiplyBy3` instead of simple shifts).
*   **Detailed Simulation Output:** Provides cycle-by-cycle state of the PC, pipeline registers, register file, and relevant memory locations.
*   **Configurable Output:** Allows users to select which states (pipeline registers, register file, memory) are displayed during simulation and for which cycle range.
*   **Modular Design:** Built with a `DriveableUnit` abstract base class, with `InputSliceSource` and `OutputSliceTarget` structs for managing inter-component connectivity and data propagation by value using `std::array`.

## Architecture Overview

The processor implements a 5-stage pipeline. The datapath is designed for 24-bit operations.
![24 Bit Processor Full Datapath](https://github.com/user-attachments/assets/218c48ee-fe9e-40d9-9a74-e49ad330c04c)
*(The full datapath. Control lines are in blue.)*

Key components include:
*   **Program Counter (PC)**
*   **Instruction Memory & Data Memory** (implemented as a single `Memory` unit)
*   **Register File** (9 registers: `$r0`, `$v0-$v3`, `$t0`, `$a0-$a1`, `$at`)
*   **ALU** (Arithmetic Logic Unit) supporting 9 operations.
*   **Control Unit**
*   **ALU Control Unit**
*   **Hazard Detection Unit**
*   **Forwarding Unit**
*   **Pipeline Registers** (IF/ID, ID/EX, EX/MEM, MEM/WB)
*   **Multiplexers** (various sizes: 2-way, 3-way, 4-way for 24-bit data; 2-way for 4-bit and 8-bit data)
*   **Adders**
*   **Sign Extender** (12-bit to 24-bit)
*   **MultiplyBy3 Units** (for branch/jump address scaling due to 3-byte word size)
*   **Concatenator** (for jump address construction)
*   **AND/OR gates** (for control logic)

The core simulation loop first allows combinational logic to settle (multiple iterations per cycle) and then simulates the clock edge by updating stateful elements (PC, Pipeline Registers, Register File write).

## Getting Started

### Prerequisites

*   A C++17 compatible compiler (e.g., GCC, Clang, MSVC).
*   The simulator has been developed and tested with **Visual Studio Community 2022**.

### Building

1.  **Clone the repository:**
    ```bash
    git clone <repository-url>
    cd <repository-directory>
    ```
2.  **Compile the `24BitProcessor.cpp` file:**
    *   **Using GCC/Clang:**
        ```bash
        g++ -std=c++17 -o processor_sim 24BitProcessor.cpp
        # or
        clang++ -std=c++17 -o processor_sim 24BitProcessor.cpp
        ```
    *   **Using Visual Studio:**
        Open Visual Studio, create a new C++ project, add `24BitProcessor.cpp` to the project, remove autogenerated .cpp file, and build. Ensure the C++ Language Standard is set to C++17 or later.

Or run from Visual Studio.

The simulator will prompt you for output preferences:
1.  **Show Pipeline Register values? (y/n, default y):**
2.  **Show Register File values? (y/n, default y):**
3.  **Show Data Memory values? (y/n, default y):**
4.  **Enter start cycle for detailed output (default 0):**
5.  **Enter end cycle for detailed output (test program ends at 77):**

The simulation will then run for a predefined number of cycles (currently 77, matching the test program's length), printing the state of the processor at each cycle according to your preferences.

## Test Program

The simulator is pre-loaded with a test program that exercises various instructions, pipeline hazards, forwarding paths, branches, and jumps. The program (and its expected register changes per loop iteration) is detailed in the accompanying research paper and embedded in `main()`.

Key memory locations initialized for the test program:
*   `Memory[0x51] = 0x000001`
*   `Memory[0x54] = 0x000003`
*   `Memory[0x57] = 0x000005`
*   `Memory[0x5A] = 0xFFFFFF`
*   `Memory[0x5D] = 0xFFFFFF`

## Output Interpretation

For each selected cycle, the simulator prints:
1.  **Current PC:** The Program Counter value.
2.  **Pipeline Registers State:** (If enabled)
    *   **IF/ID:** `PC+3 | Op Rs Rt Rd Smt Func` (R-type) or `PC+3 | Op Rs Rt | Imm` (I-type) or `PC+3 | Op | Targ Addr` (J-type)
    *   **ID/EX:** `WB|M|EX| Reg1 Data| Reg2 Data|ImmSignExt|Rs#|Rt#|Rd#`
        *   WB: `MemToReg RegWrite`
        *   M: `MemRead MemWrite`
        *   EX: `RegDst ALUOp ALUSrc`
    *   **EX/MEM:** `WB|M|ALU Result|WriteData|WrReg#`
        *   WB: `MemToReg RegWrite`
        *   M: `MemRead MemWrite`
    *   **MEM/WB:** `(RegWrite|MemToReg)|Read Data|ALUResult|WrReg#`
3.  **Register File State:** (If enabled) Lists all registers (`$r0` to `$at`), their hex values, and binary values.
4.  **Data Memory State:** (If enabled) Shows a relevant slice of data memory (addresses `0x51` to `0x5D` by default), with hex and binary values.

![image](https://github.com/user-attachments/assets/287f82f6-93f7-48e0-a7c8-997504bf51f1)

*(Example of full readout for cycle 13)*

## Instruction Field Breakdown (24-bit Instructions)

All instructions are 24 bits wide. The fields are arranged from Most Significant Bit (MSB) to Least Significant Bit (LSB).

**R-type (Register-type):**
Used for operations primarily between registers (e.g., `add`, `sub`, `sll`).

| Bits     | Field   | Size   | Description                                             |
| :------- | :------ | :----- | :------------------------------------------------------ |
| `23-20`  | Opcode  | 4 bits | Defines the instruction type (0000 for R-type).         |
| `19-16`  | Rs      | 4 bits | First source register operand.                          |
| `15-12`  | Rt      | 4 bits | Second source register operand.                         |
| `11-8`   | Rd      | 4 bits | Destination register operand.                           |
| `7-4`    | Shamt   | 4 bits | Shift amount (used only for shift instructions, 0 otherwise). |
| `3-0`    | Funct   | 4 bits | Function code; specifies the R-type operation.          |

**I-type (Immediate-type):**
Used for operations with an immediate value (e.g., `addi`, `lw`, `sw`, `bne`).

| Bits     | Field              | Size    | Description                                                                |
| :------- | :----------------- | :------ | :------------------------------------------------------------------------- |
| `23-20`  | Opcode             | 4 bits  | Defines the instruction.                                                   |
| `19-16`  | Rs                 | 4 bits  | Source register operand (or base register for `lw`/`sw`).                 |
| `15-12`  | Rt                 | 4 bits  | Destination register operand (or source register for `sw`).                |
| `11-0`   | Immediate / Offset | 12 bits | A constant value or address offset. Can be signed or unsigned.             |

**J-type (Jump-type):**
Used for unconditional jumps (e.g., `j`).

| Bits     | Field              | Size    | Description                                                                          |
| :------- | :----------------- | :------ | :----------------------------------------------------------------------------------- |
| `23-20`  | Opcode             | 4 bits  | Defines the instruction (0111 for `j`).                                              |
| `19-0`   | Target Address     | 20 bits | Partial address for the jump target. Combined with PC upper bits & scaled by 3.      |

## Instruction Set Details

| Mnemonic | Opcode | Funct | Format | Assembly Syntax             | Notes                                     |
| :------- | :----- | :---- | :----- | :-------------------------- | :---------------------------------------- |
| `add`    | `0000` | `0001`| R      | `add rd, rs, rt`            |                                           |
| `sub`    | `0000` | `0010`| R      | `sub rd, rs, rt`            |                                           |
| `multlow`| `0000` | `0011`| R      | `multlow rd, rs, rt`        | Lower 24 bits of signed multiply          |
| `and`    | `0000` | `0100`| R      | `and rd, rs, rt`            |                                           |
| `or`     | `0000` | `0101`| R      | `or rd, rs, rt`             |                                           |
| `xor`    | `0000` | `0110`| R      | `xor rd, rs, rt`            |                                           |
| `slt`    | `0000` | `0111`| R      | `slt rd, rs, rt`            | Set on Less Than (signed)                 |
| `sll`    | `0000` | `1000`| R      | `sll rd, rt, shamt`         | Rs field unused by ALU for shamt          |
| `srl`    | `0000` | `1001`| R      | `srl rd, rt, shamt`         | Rs field unused by ALU for shamt          |
| `nop`    | `0000` | `1000`| R      | `nop`                       | Encoded as `sll $r0, $r0, 0`              |
| `addi`   | `0001` | N/A   | I      | `addi rt, rs, immediate`    | 12-bit signed immediate                   |
| `lui`    | `0010` | N/A   | I      | `lui rt, immediate`         | 12-bit immediate loaded to upper half     |
| `ori`    | `0011` | N/A   | I      | `ori rt, rs, immediate`     | 12-bit zero-extended immediate            |
| `sw`     | `0100` | N/A   | I      | `sw rt, offset(rs)`         | 12-bit signed offset                      |
| `lw`     | `0101` | N/A   | I      | `lw rt, offset(rs)`         | 12-bit signed offset                      |
| `bne`    | `0110` | N/A   | I      | `bne rs, rt, offset`        | 12-bit signed offset (word-aligned by 3)  |
| `j`      | `0111` | N/A   | J      | `j target_address`          | 20-bit address field (word-aligned by 3)  |

*Opcodes and Funct codes are shown in binary.*
*Register fields (Rd, Rs, Rt) are 4 bits each.*
*Shamt field is 4 bits.*

## Contributing

This is free and unencumbered software released into the public domain.

Anyone is free to copy, modify, publish, use, compile, sell, or
distribute this software, either in source code form or as a compiled
binary, for any purpose, commercial or non-commercial, and by any
means.

For more information, please refer to <http://unlicense.org/>

## License

This project is released into the public domain. See the [UNLICENSE](UNLICENSE) file or <http://unlicense.org/> for more details.

## Acknowledgements

*   This project was developed for a Computer Architecture course final project.
*   The initial structure and component logic were developed with assistance from Google's Gemini 2.5 Pro.
*   The MIPS architecture, as described in textbooks like "Computer Organization and Design" by Patterson and Hennessy, served as a foundational reference.
